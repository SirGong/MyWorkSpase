# 面试常考算法

## 输出集合子集

给定一个集合S(没有重复元素), 输出它所有的子集 输入  1 2 3 输出 1, 2, 12, 3, 13, 23, 123

```java
public static void subSet(int[] set){
        int n = set.length;
        for (int i = 1; i < 1<<n ; i++) {//如果没有空集，就直接循环2^-1次
            String setStr = Integer.toBinaryString(i);//转换为二进制
            int unChoose = n-setStr.length();
            System.out.print("{");
            for (int j = 0; j < setStr.length(); j++) {
                if(setStr.charAt(j) == '1'){
                    System.out.print(set[unChoose+j]);
                }
            }
            System.out.println("}");
        }
    }
```

## 逆置单链表

```java
//三指针法
public static ListNode reverseList(ListNode head) {
        ListNode reverseHead = null;
        ListNode pNode = head;
        ListNode pPrev = null;
        while (pNode != null) {
            ListNode pNext = pNode.next;
            if (pNext == null)
                reverseHead = pNode;
            pNode.next = pPrev;
            pPrev = pNode;
            pNode = pNext;
        }
        return reverseHead;
    }
//递归
public static ListNode reverseListRec(ListNode head) {
    if (head == null || head.next == null)
        return head;
    ListNode newHead = reverseListRec(head.next);
    head.next.next = head;
    head.next = null;
    return newHead;
}
```

## 逆序打印链表

```java
/**
* 逆序打印链表，不改变链表结构
* @param head 链表头结点
*/
//利用一个栈将节点压入栈中，边弹栈边打印
public static void printList(List head){
    Stack<List> stack = new Stack<>();
    List pNode = head;
    while(pNode!=null){
        stack.push(pNode);
        pNode = pNode.next;
    }
    while(!stack.isEmpty()){
        pNode = stack.peek();
        System.out.print(pNode.val+"\t");
        stack.pop();
    }
}
//递归打印
public static void PintListRev(List head){
    if(head!=null){//头结点不为空才继续递归
        if(head.next!=null){
            PintListRev(head.next);
        }
        System.out.print(head.val+"\t");
    }
}
```

## 返回单链表的倒数第K个节点

```java
public static ListNode find(ListNode head, int k) {
    if (head == null || k <= 0) //检查head是否为空，k是否合法
        return null;
    ListNode pAHead = head;//第一个指针先向前走K-1步
    for (int i = 0; i < k - 1; i++) {
        if (pAHead.next != null) //节点总数是否少于k
            pAHead = pAHead.next;
        else return null;
    }
    ListNode pBHead = head;
    while (pAHead.next != null) {
        pAHead = pAHead.next;
        pBHead = pBHead.next;
    }
    return pBHead;
}

//写法二
public ListNode FindKthToTail(ListNode head,int k) {
    if (head == null || k <= 0) //检查head是否为空，k是否合法
        return null;

    ListNode p = head;
    ListNode q = head;
    int i =0;
    for(;p!=null;i++){
        if(i>=k){
            q = q.next;
        }
        p = p.next; //让p指针先向前走k-1步
    }
    return i<k? null:q;
}
```

## 分层打印二叉树

```java
public static void levelPrint(Node root) {
    if (root == null)
        return;
    Queue<Node> queue = new LinkedBlockingQueue<>();
    Node current = null;
    queue.offer(root);//根节点入队
    while (!queue.isEmpty()) {
        current = queue.poll();
        System.out.print(current.val);

        if (current.left != null)//左子节点入队
            queue.offer(current.left);

        if (current.right != null)//右子节点入队
            queue.offer(current.right);
    }
}
```

## 合并两个有序链表使之依然有序

```java
public static Node merge(Node head1, Node head2) {
    Node newHead = new Node(0);
    Node current = newHead;
    //两根链表都不为空的时候进行比较尾插入新链表
    while (head1 != null && head2 != null) {
        if (head1.val < head2.val) {
            current.next = head1;
            head1 = head1.next;
        } else {
            current.next = head2;
            head2 = head2.next;
        }
        current = current.next;
    }
    //循环结束最少有一根链表为空
    if (head1 == null)
        current.next = head2;
    if (head2 == null)
        current.next = head1;
    //去掉新链表的头
    return newHead.next;
}
//递归解法
public static Node mergeRec(Node head1, Node head2) {
    if (head1 == null) {
        return head2;
    } else if (head2 == null) {
        return head1;
    } else {
        if (head1.val < head2.val) {
            head1.next = mergeRec(head1.next, head2);
            return head1;
        } else {
            head2.next = mergeRec(head1, head2.next);
            return head2;
        }
    }
}
```

## 双栈实现队列

```java
public class TwoStackToQueue {
    Stack<Integer> stack1 = new Stack<>();
    Stack<Integer> stack2 = new Stack<>();

    public void  push(Integer node){
        //stack1作为辅助栈进行入队操作
        //stack2作为主栈用来保存已经入队的数据
        if(stack2.isEmpty()){
            stack2.push(node);
        }else{
            //stack2不为空，就将所有的数据依次弹出压入stack1
            while(!stack2.isEmpty()){
                stack1.push(stack2.pop());
            }
            stack2.push(node);
            //将stack1的数据全部压回来
            while(!stack1.isEmpty()){
                stack2.push(stack1.pop());
            }
        }
    }

    public int pop(){
       //出栈弹出stack2栈顶的数据即可
        return stack2.pop();
    }
}
```

##  让奇数位于数组的前半部分

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 

```java
public static void reOderArray(int[] arr){
    //queue1放奇数，queue2放偶数
    Queue<Integer> queue1 = new LinkedList<>();
    Queue<Integer> queue2 = new LinkedList<>();

    for (int i = 0; i < arr.length; i++) {
        if(isOdd(arr[i])){
            queue1.offer(arr[i]);
        }else {
            queue2.offer(arr[i]);
        }
    }
    int i = 0;
    while (!queue1.isEmpty()){
        arr[i++] = queue1.poll();
    }
    while (!queue2.isEmpty()){
        arr[i++] = queue2.poll();
    }
}
public static boolean isOdd(int num){
    //是奇数返回true
    if((num & 1) == 1 ){
        return true;
    }else {
        return false;
    }
}
```

 ## 树的子树

```java
/**
     * 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
     */
public class HasSubTree {
    public static boolean hasSubTree(TreeNode rootA, TreeNode rootB){
        if(rootA == null || rootB == null){
            return false;
        }
        //遍历A树，找到与B树根节点相同的子树
        if(rootA.val == rootB.val){
            //判断两颗子树是否相等
            if(judge(rootA,rootB)){
                return true;
            }
        }
        return hasSubTree(rootA.left,rootB) || hasSubTree(rootA.right,rootB);
    }

    private static boolean judge(TreeNode rootA, TreeNode rootB) {
        //判断两颗树是否相等
        //B树已经递归完全为空时说明前面已经匹配
        if(rootB == null){
            return true;
        }
        //A树已经为空了还在递归说明子树还未匹配完全
        if(rootA == null){
            return false;
        }
        //节点相等后判断左子树和右子树
        if(rootA.val == rootB.val){
            return judge(rootA.left,rootB.left) && judge(rootA.right,rootB.right);
        }
        //未匹配上
        return false;
    }
```

## 二叉树的镜像树

```java
/**
 * 二叉树的镜像定义：源二叉树
 *     	    8
 *     	   /  \
 *     	  6   10
 *     	 / \  / \
 *     	5  7 9 11
 *     	镜像二叉树
 *     	    8
 *     	   /  \
 *     	  10   6
 *     	 / \  / \
 *     	11 9 7  5
 */
public class MirrorTree {
    public static void mirror(TreeNode root){
        if(root == null)
            return;
        //左右子树进行交换
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        //递归处理左右子树
        mirror(root.left);
        mirror(root.right);
    }
}
```

## 顺时针打印矩阵

```java
public static ArrayList<Integer> printMatrixArray(int[][] array) {
    ArrayList<Integer> resList = new ArrayList<>();
    //定义矩阵四下的边界
    int up = 0;
    int down = array.length-1;
    int left = 0;
    int right = array[0].length-1;
    //向左向右向上向下遍历之后将边界缩小
    while (true) {
        //第一行向右打印
        for (int i = left; i <= right; i++) {
            resList.add(array[up][i]);
        }
        //向下逼近
        up++;
        if (up > down)
            break;

        //最右边一列向下打印
        for (int i = up; i <= down; i++) {
            resList.add(array[i][right]);
        }
        //向左逼近
        right--;
        if (left > right)
            break;
        //最下边一行向左打印
        for (int i = right; i >= left; i--) {
            resList.add(array[down][i]);
        }

        //向上逼近
        down--;
        if (up > down)
            break;
        //最左边一列向上打印
        for (int i = down; i >= up; i--) {
            resList.add(array[i][left]);
        }
        left++;
        if (left > right)
            break;
    }
    return resList;
}
```

## 快速排序

```java
public static void quickSort2(int[] array, int start, int end) {
    if (start > end)
        return;

    int l = start;
    int r = end;
    //基准值
    int tag = array[l];

    while (l < r) {
        //从左向右找到一个比目标值大的
        while (l < r && array[l] < tag)
            l++;

        //从右向左找，找到一个比目标值小的
        while (l < r && array[r] > tag)
            r--;
        if (l < r && array[l] == array[r]) {
            l++;
        } else {
            int temp = array[l];
            array[l] = array[r];
            array[r] = temp;
        }
        //向左递归
        quickSort2(array, start, l - 1);
        //向右递归
        quickSort2(array, r + 1, end);

    }
}
```

## 冒泡排序

   

```java
 //优化：如果在某一趟排序中没有发生一次交换，即已经有序，即可退出
public static void bubbleSort(int[] array){
    boolean flag = false;//设置标志
    int temp = 0;
    for (int i = 0; i < array.length - 1; i++) {
        for (int j = 0; j < array.length - 1 - i; j++) {
            if (array[j] > array[j + 1]) {
                flag = true;
                temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
        //System.out.println("第"+(i+1)+"趟排序为：");
        //System.out.println(Arrays.toString(array));
        if(!flag){
            break;
        }else {
            flag = true;
        }
    }
}
```

## 选择排序

```java
public static void selectSort(int[] array) {
    for (int i = 0; i < array.length - 1; i++) {
        //选择
        int minIndex = i;//假设第一个为最小
        int min = array[i];//保存当前的值
        for (int j = i + 1; j < array.length; j++) {
            if (array[j] < array[minIndex]) {
                minIndex = j;
                min = array[j];
            }
        }
        //交换
        if (minIndex != i) {
            array[minIndex] = array[i];
            array[i] = min;
        }
    }
}
```

## 桶排序

```java
//如果有负数需要进行特殊处理
public static void radixSort(int[] arr) {
    //针对每个元素的各位进行处理
    //定义一个二维数组，一共10个桶，每个桶 arr.length为了防止数据溢出
    int[][] bucket = new int[10][arr.length];
    //记录每个桶中实际放入多少个数据
    //bucketElementCount[0] 记录这个桶放入的数据位数为0
    int[] bucketElementCount = new int[10];
    //假设第一个数为数组最大的数
    int max = arr[0];
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    //得到的最大的数，判断的它的位数
    int maxLength = (max + "").length();
    for (int i = 0, n = 1; i < maxLength; i++, n *= 10) {
        //第一次处理个位，第二次处理十位，以此类推
        for (int j = 0; j < arr.length; j++) {
            int digitOfElement = arr[j] / n % 10;
            //放入到对应桶里
            bucket[digitOfElement][bucketElementCount[digitOfElement]] = arr[j];
            bucketElementCount[digitOfElement]++;
        }
        //按照桶的顺序依次取出数据放入原来的数组
        int index = 0;
        for (int k = 0; k < bucketElementCount.length; k++) {
            //如果桶中有数据，才取出放入原数组
            if (bucketElementCount[k] != 0) {
                //循环第k个桶
                for (int l = 0; l < bucketElementCount[k]; l++) {
                    //取出元素，放入arr中
                    arr[index++] = bucket[k][l];
                }
            }
            //置零，防止计数错误
            bucketElementCount[k] = 0;
        }
    	System.out.println("第" + (i + 1) + "轮处理后的结果为：" + Arrays.toString(arr));
	}
}
```

## 插入排序

```java
public static void insertSort(int[] array) {
    //定义待插入的数
    for (int i = 1; i < array.length; i++) {
        int insertVal = array[i];
        int insertIndex = i - 1;
        //insertIndex >= 0 ：防止索引越界
        while (insertIndex >= 0 && insertVal < array[insertIndex]) {
            array[insertIndex + 1] = array[insertIndex];
            insertIndex--;
        }
        //循环结束，已经找到插入位置：insertIndex+1
        array[insertIndex+1] = insertVal;
    }

}
```

## 归并排序

```java
//分治方法
public static void mergeSort(int[] arr, int left, int right, int[] temp) {
    if (left < right) {
        int mid = (left + right) / 2;//中间索引
        //向左递归分解
        mergeSort(arr, left, mid, temp);
        //向右递归分解
        mergeSort(arr, mid + 1, right, temp);
        //合并
        merge(arr, left, mid, right, temp);

    }

}
//合并的方法
/**
     * @param arr   待排序的数组
     * @param left  左边有序序列的初始值
     * @param mid   中间索引
     * @param right 右边有序序列最右边的索引
     * @param temp  中转数组
     */
public static void merge(int[] arr, int left, int mid, int right, int[] temp) {
    int i = left;//初始化，指向左边有序序列的左边索引
    int j = mid + 1;
    int t = 0;
    //  将左右两边的有序序列的数按照规则填充进temp中
    while (i <= mid && j <= right) {
        if (arr[i] < arr[j]) {
            temp[t] = arr[i];
            i++;
        } else {
            temp[t] = arr[j];
            j++;
        }
        t++;
    }
    //把剩余一边有数据的填充到temp中
    while (i <= mid) {//左边还有剩余元素
        temp[t++] = arr[i++];
    }
    while (j <= right) {
        temp[t++] = arr[j++];
    }
    //把temp拷贝到arr中
    t = 0;
    int tempLeft = left;//因为分治，所以每次拷贝的并不是原来所有的数组
    while (tempLeft <= right) {
        arr[tempLeft++] = temp[t++];
    }
}
```

## 希尔排序

```java
public static void shellSort(int[] array) {
    int temp = 0;
    //gap作为希尔排序的步长
    for (int gap = array.length / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < array.length; i++) {
            //遍历各组的元素
            for (int j = i - gap; j >= 0; j -= gap) {
                //如果当前元素大于加上步长后的那个元素，则交换
                if (array[j] > array[j + gap]) {
                    temp = array[j];
                    array[j] = array[j + gap];
                    array[j + gap] = temp;
                }
            }
        }
        System.out.println(Arrays.toString(array));
    }
}

//采用交换法的希尔排序反而变得更慢了
//优化：改进为移位法
public static void shellSort2(int[] array) {
    //从第gap个元素逐渐对其各自的组进行直接插入排序
    for (int gap = array.length / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < array.length; i++) {
            int j = i;
            int temp = array[j];
            while (j - gap >= 0 && temp < array[j - gap]) {
                //移动
                array[j] = array[j - gap];
                j -= gap;
            }
            //循环结束，已经找到插入位置
            array[j] = temp;
        }
    }
    System.out.println(Arrays.toString(array));
}
```

## 堆排序

```java
public static void heapSort(int[] arr) {
    int temp = 0;
    System.out.println("堆排序~~");
    //首先完成大顶堆或者小顶堆
    for (int i = arr.length / 2 - 1; i >= 0; i--) {
        adjustHeap(arr, i, arr.length);
    }
    for (int j = arr.length - 1; j > 0; j--) {
        //交换
        temp = arr[j];
        arr[j] = arr[0];
        arr[0] = temp;
        adjustHeap(arr, 0, j);
    }
}
//此方法用来调整成为大顶堆
/**
* 完成将以 i 对应的非叶子节点的树调整成大顶堆
* @param arr    待调整的数组
* @param i      表示非叶子结点在数组中的索引
* @param length 表示对多少个元素进行调整，length相继减少
*/
public static void adjustHeap(int[] arr, int i, int length) {
    int temp = arr[i];//保存当前节点数据
    //开始调整
    //
    for (int k = 2 * i + 1; k < length; k = k * 2 + 1) {
        //左子节点的值小于右子节点的值
        if (k + 1 < length && arr[k] < arr[k + 1]) {
            k++;//指向右子节点
        }
        //子节点的值大于父节点的值
        if (arr[k] > temp) {
            arr[i] = arr[k];//把较大的值赋值给当前节点
            i = k;//继续调整值较大的子节点
        } else {
            break;//从左至右，从下至上
        }
    }
    //for循环结束后，已经将以i为父节点的值放在了顶上，局部调整好了
    arr[i] = temp;
}
```

## Scanner动态输入解决死循环

```java
public static void main(String[] args) {
    ArrayList<String> stringList = new ArrayList<>();
    Scanner in = new Scanner(System.in);
    //如果是数组就定义一个游标
    while (true) {
        String str = in.nextLine();
        if(str.equals("")){
            break;
        }else {
            stringList.add(str);
        }
    }
    System.out.println(stringList.toString());
}
```

