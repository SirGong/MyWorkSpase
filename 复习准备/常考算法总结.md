# 面试常考算法

## 输出集合子集

给定一个集合S(没有重复元素), 输出它所有的子集 输入  1 2 3 输出 1, 2, 12, 3, 13, 23, 123

```java
public static void subSet(int[] set){
        int n = set.length;
        for (int i = 1; i < 1<<n ; i++) {//如果没有空集，就直接循环2^-1次
            String setStr = Integer.toBinaryString(i);//转换为二进制
            int unChoose = n-setStr.length();
            System.out.print("{");
            for (int j = 0; j < setStr.length(); j++) {
                if(setStr.charAt(j) == '1'){
                    System.out.print(set[unChoose+j]);
                }
            }
            System.out.println("}");
        }
    }
```

## 逆置单链表

```java
//三指针法
public static ListNode reverseList(ListNode head) {
        ListNode reverseHead = null;
        ListNode pNode = head;
        ListNode pPrev = null;
        while (pNode != null) {
            ListNode pNext = pNode.next;
            if (pNext == null)
                reverseHead = pNode;
            pNode.next = pPrev;
            pPrev = pNode;
            pNode = pNext;
        }
        return reverseHead;
    }
//递归
public static ListNode reverseListRec(ListNode head) {
    if (head == null || head.next == null)
        return head;
    ListNode newHead = reverseListRec(head.next);
    head.next.next = head;
    head.next = null;
    return newHead;
}
```

## 逆序打印链表

```java
/**
* 逆序打印链表，不改变链表结构
* @param head 链表头结点
*/
//利用一个栈将节点压入栈中，边弹栈边打印
public static void printList(List head){
    Stack<List> stack = new Stack<>();
    List pNode = head;
    while(pNode!=null){
        stack.push(pNode);
        pNode = pNode.next;
    }
    while(!stack.isEmpty()){
        pNode = stack.peek();
        System.out.print(pNode.val+"\t");
        stack.pop();
    }
}
//递归打印
public static void PintListRev(List head){
    if(head!=null){//头结点不为空才继续递归
        if(head.next!=null){
            PintListRev(head.next);
        }
        System.out.print(head.val+"\t");
    }
}
```

## 返回单链表的倒数第K个节点

```java
public static ListNode find(ListNode head, int k) {
    if (head == null || k <= 0) //检查head是否为空，k是否合法
        return null;
    ListNode pAHead = head;//第一个指针先向前走K-1步
    for (int i = 0; i < k - 1; i++) {
        if (pAHead.next != null) //节点总数是否少于k
            pAHead = pAHead.next;
        else return null;
    }
    ListNode pBHead = head;
    while (pAHead.next != null) {
        pAHead = pAHead.next;
        pBHead = pBHead.next;
    }
    return pBHead;
}

//写法二
public ListNode FindKthToTail(ListNode head,int k) {
    if (head == null || k <= 0) //检查head是否为空，k是否合法
        return null;

    ListNode p = head;
    ListNode q = head;
    int i =0;
    for(;p!=null;i++){
        if(i>=k){
            q = q.next;
        }
        p = p.next; //让p指针先向前走k-1步
    }
    return i<k? null:q;
}
```

## 分层打印二叉树

```java
public static void levelPrint(Node root) {
    if (root == null)
        return;
    Queue<Node> queue = new LinkedBlockingQueue<>();
    Node current = null;
    queue.offer(root);//根节点入队
    while (!queue.isEmpty()) {
        current = queue.poll();
        System.out.print(current.val);

        if (current.left != null)//左子节点入队
            queue.offer(current.left);

        if (current.right != null)//右子节点入队
            queue.offer(current.right);
    }
}
```

## 合并两个有序链表使之依然有序

```java
public static Node merge(Node head1, Node head2) {
    Node newHead = new Node(0);
    Node current = newHead;
    //两根链表都不为空的时候进行比较尾插入新链表
    while (head1 != null && head2 != null) {
        if (head1.val < head2.val) {
            current.next = head1;
            head1 = head1.next;
        } else {
            current.next = head2;
            head2 = head2.next;
        }
        current = current.next;
    }
    //循环结束最少有一根链表为空
    if (head1 == null)
        current.next = head2;
    if (head2 == null)
        current.next = head1;
    //去掉新链表的头
    return newHead.next;
}
//递归解法
public static Node mergeRec(Node head1, Node head2) {
    if (head1 == null) {
        return head2;
    } else if (head2 == null) {
        return head1;
    } else {
        if (head1.val < head2.val) {
            head1.next = mergeRec(head1.next, head2);
            return head1;
        } else {
            head2.next = mergeRec(head1, head2.next);
            return head2;
        }
    }
}
```

## 双栈实现队列

```java
public class TwoStackToQueue {
    Stack<Integer> stack1 = new Stack<>();
    Stack<Integer> stack2 = new Stack<>();

    public void  push(Integer node){
        //stack1作为辅助栈进行入队操作
        //stack2作为主栈用来保存已经入队的数据
        if(stack2.isEmpty()){
            stack2.push(node);
        }else{
            //stack2不为空，就将所有的数据依次弹出压入stack1
            while(!stack2.isEmpty()){
                stack1.push(stack2.pop());
            }
            stack2.push(node);
            //将stack1的数据全部压回来
            while(!stack1.isEmpty()){
                stack2.push(stack1.pop());
            }
        }
    }

    public int pop(){
       //出栈弹出stack2栈顶的数据即可
        return stack2.pop();
    }
}
```

##  让奇数位于数组的前半部分

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 

```java
public static void reOderArray(int[] arr){
    //queue1放奇数，queue2放偶数
    Queue<Integer> queue1 = new LinkedList<>();
    Queue<Integer> queue2 = new LinkedList<>();

    for (int i = 0; i < arr.length; i++) {
        if(isOdd(arr[i])){
            queue1.offer(arr[i]);
        }else {
            queue2.offer(arr[i]);
        }
    }
    int i = 0;
    while (!queue1.isEmpty()){
        arr[i++] = queue1.poll();
    }
    while (!queue2.isEmpty()){
        arr[i++] = queue2.poll();
    }
}
public static boolean isOdd(int num){
    //是奇数返回true
    if((num & 1) == 1 ){
        return true;
    }else {
        return false;
    }
}
```

 ## 树的子树

```java
/**
     * 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
     */
public class HasSubTree {
    public static boolean hasSubTree(TreeNode rootA, TreeNode rootB){
        if(rootA == null || rootB == null){
            return false;
        }
        //遍历A树，找到与B树根节点相同的子树
        if(rootA.val == rootB.val){
            //判断两颗子树是否相等
            if(judge(rootA,rootB)){
                return true;
            }
        }
        return hasSubTree(rootA.left,rootB) || hasSubTree(rootA.right,rootB);
    }

    private static boolean judge(TreeNode rootA, TreeNode rootB) {
        //判断两颗树是否相等
        //B树已经递归完全为空时说明前面已经匹配
        if(rootB == null){
            return true;
        }
        //A树已经为空了还在递归说明子树还未匹配完全
        if(rootA == null){
            return false;
        }
        //节点相等后判断左子树和右子树
        if(rootA.val == rootB.val){
            return judge(rootA.left,rootB.left) && judge(rootA.right,rootB.right);
        }
        //未匹配上
        return false;
    }
```

## 二叉树的镜像树

```java
/**
 * 二叉树的镜像定义：源二叉树
 *     	    8
 *     	   /  \
 *     	  6   10
 *     	 / \  / \
 *     	5  7 9 11
 *     	镜像二叉树
 *     	    8
 *     	   /  \
 *     	  10   6
 *     	 / \  / \
 *     	11 9 7  5
 */
public class MirrorTree {
    public static void mirror(TreeNode root){
        if(root == null)
            return;
        //左右子树进行交换
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        //递归处理左右子树
        mirror(root.left);
        mirror(root.right);
    }
}
```

## 顺时针打印矩阵

```java
public static ArrayList<Integer> printMatrixArray(int[][] array) {
    ArrayList<Integer> resList = new ArrayList<>();
    //定义矩阵四下的边界
    int up = 0;
    int down = array.length-1;
    int left = 0;
    int right = array[0].length-1;
    //向左向右向上向下遍历之后将边界缩小
    while (true) {
        //第一行向右打印
        for (int i = left; i <= right; i++) {
            resList.add(array[up][i]);
        }
        //向下逼近
        up++;
        if (up > down)
            break;

        //最右边一列向下打印
        for (int i = up; i <= down; i++) {
            resList.add(array[i][right]);
        }
        //向左逼近
        right--;
        if (left > right)
            break;
        //最下边一行向左打印
        for (int i = right; i >= left; i--) {
            resList.add(array[down][i]);
        }

        //向上逼近
        down--;
        if (up > down)
            break;
        //最左边一列向上打印
        for (int i = down; i >= up; i--) {
            resList.add(array[i][left]);
        }
        left++;
        if (left > right)
            break;
    }
    return resList;
}
```

## 快速排序

```java
public static void quickSort2(int[] array, int start, int end) {
    if (start > end)
        return;

    int l = start;
    int r = end;
    //基准值
    int tag = array[l];

    while (l < r) {
        //从左向右找到一个比目标值大的
        while (l < r && array[l] < tag)
            l++;

        //从右向左找，找到一个比目标值小的
        while (l < r && array[r] > tag)
            r--;
        if (l < r && array[l] == array[r]) {
            l++;
        } else {
            int temp = array[l];
            array[l] = array[r];
            array[r] = temp;
        }
        //向左递归
        quickSort2(array, start, l - 1);
        //向右递归
        quickSort2(array, r + 1, end);

    }
}
```

## 冒泡排序

   

```java
 //优化：如果在某一趟排序中没有发生一次交换，即已经有序，即可退出
public static void bubbleSort(int[] array){
    boolean flag = false;//设置标志
    int temp = 0;
    for (int i = 0; i < array.length - 1; i++) {
        for (int j = 0; j < array.length - 1 - i; j++) {
            if (array[j] > array[j + 1]) {
                flag = true;
                temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
        //System.out.println("第"+(i+1)+"趟排序为：");
        //System.out.println(Arrays.toString(array));
        if(!flag){
            break;
        }else {
            flag = true;
        }
    }
}
```

## 选择排序

```java
public static void selectSort(int[] array) {
    for (int i = 0; i < array.length - 1; i++) {
        //选择
        int minIndex = i;//假设第一个为最小
        int min = array[i];//保存当前的值
        for (int j = i + 1; j < array.length; j++) {
            if (array[j] < array[minIndex]) {
                minIndex = j;
                min = array[j];
            }
        }
        //交换
        if (minIndex != i) {
            array[minIndex] = array[i];
            array[i] = min;
        }
    }
}
```

## 桶排序

```java
//如果有负数需要进行特殊处理
public static void radixSort(int[] arr) {
    //针对每个元素的各位进行处理
    //定义一个二维数组，一共10个桶，每个桶 arr.length为了防止数据溢出
    int[][] bucket = new int[10][arr.length];
    //记录每个桶中实际放入多少个数据
    //bucketElementCount[0] 记录这个桶放入的数据位数为0
    int[] bucketElementCount = new int[10];
    //假设第一个数为数组最大的数
    int max = arr[0];
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    //得到的最大的数，判断的它的位数
    int maxLength = (max + "").length();
    for (int i = 0, n = 1; i < maxLength; i++, n *= 10) {
        //第一次处理个位，第二次处理十位，以此类推
        for (int j = 0; j < arr.length; j++) {
            int digitOfElement = arr[j] / n % 10;
            //放入到对应桶里
            bucket[digitOfElement][bucketElementCount[digitOfElement]] = arr[j];
            bucketElementCount[digitOfElement]++;
        }
        //按照桶的顺序依次取出数据放入原来的数组
        int index = 0;
        for (int k = 0; k < bucketElementCount.length; k++) {
            //如果桶中有数据，才取出放入原数组
            if (bucketElementCount[k] != 0) {
                //循环第k个桶
                for (int l = 0; l < bucketElementCount[k]; l++) {
                    //取出元素，放入arr中
                    arr[index++] = bucket[k][l];
                }
            }
            //置零，防止计数错误
            bucketElementCount[k] = 0;
        }
    	System.out.println("第" + (i + 1) + "轮处理后的结果为：" + Arrays.toString(arr));
	}
}
```

## 插入排序

```java
public static void insertSort(int[] array) {
    //定义待插入的数
    for (int i = 1; i < array.length; i++) {
        int insertVal = array[i];
        int insertIndex = i - 1;
        //insertIndex >= 0 ：防止索引越界
        while (insertIndex >= 0 && insertVal < array[insertIndex]) {
            array[insertIndex + 1] = array[insertIndex];
            insertIndex--;
        }
        //循环结束，已经找到插入位置：insertIndex+1
        array[insertIndex+1] = insertVal;
    }

}
```

## 归并排序

```java
//分治方法
public static void mergeSort(int[] arr, int left, int right, int[] temp) {
    if (left < right) {
        int mid = (left + right) / 2;//中间索引
        //向左递归分解
        mergeSort(arr, left, mid, temp);
        //向右递归分解
        mergeSort(arr, mid + 1, right, temp);
        //合并
        merge(arr, left, mid, right, temp);

    }

}
//合并的方法
/**
     * @param arr   待排序的数组
     * @param left  左边有序序列的初始值
     * @param mid   中间索引
     * @param right 右边有序序列最右边的索引
     * @param temp  中转数组
     */
public static void merge(int[] arr, int left, int mid, int right, int[] temp) {
    int i = left;//初始化，指向左边有序序列的左边索引
    int j = mid + 1;
    int t = 0;
    //  将左右两边的有序序列的数按照规则填充进temp中
    while (i <= mid && j <= right) {
        if (arr[i] < arr[j]) {
            temp[t] = arr[i];
            i++;
        } else {
            temp[t] = arr[j];
            j++;
        }
        t++;
    }
    //把剩余一边有数据的填充到temp中
    while (i <= mid) {//左边还有剩余元素
        temp[t++] = arr[i++];
    }
    while (j <= right) {
        temp[t++] = arr[j++];
    }
    //把temp拷贝到arr中
    t = 0;
    int tempLeft = left;//因为分治，所以每次拷贝的并不是原来所有的数组
    while (tempLeft <= right) {
        arr[tempLeft++] = temp[t++];
    }
}
```

## 希尔排序

```java
public static void shellSort(int[] array) {
    int temp = 0;
    //gap作为希尔排序的步长
    for (int gap = array.length / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < array.length; i++) {
            //遍历各组的元素
            for (int j = i - gap; j >= 0; j -= gap) {
                //如果当前元素大于加上步长后的那个元素，则交换
                if (array[j] > array[j + gap]) {
                    temp = array[j];
                    array[j] = array[j + gap];
                    array[j + gap] = temp;
                }
            }
        }
        System.out.println(Arrays.toString(array));
    }
}

//采用交换法的希尔排序反而变得更慢了
//优化：改进为移位法
public static void shellSort2(int[] array) {
    //从第gap个元素逐渐对其各自的组进行直接插入排序
    for (int gap = array.length / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < array.length; i++) {
            int j = i;
            int temp = array[j];
            while (j - gap >= 0 && temp < array[j - gap]) {
                //移动
                array[j] = array[j - gap];
                j -= gap;
            }
            //循环结束，已经找到插入位置
            array[j] = temp;
        }
    }
    System.out.println(Arrays.toString(array));
}
```

## 堆排序

```java
public static void heapSort(int[] arr) {
    int temp = 0;
    System.out.println("堆排序~~");
    //首先完成大顶堆或者小顶堆
    for (int i = arr.length / 2 - 1; i >= 0; i--) {
        adjustHeap(arr, i, arr.length);
    }
    for (int j = arr.length - 1; j > 0; j--) {
        //交换
        temp = arr[j];
        arr[j] = arr[0];
        arr[0] = temp;
        adjustHeap(arr, 0, j);
    }
}
//此方法用来调整成为大顶堆
/**
* 完成将以 i 对应的非叶子节点的树调整成大顶堆
* @param arr    待调整的数组
* @param i      表示非叶子结点在数组中的索引
* @param length 表示对多少个元素进行调整，length相继减少
*/
public static void adjustHeap(int[] arr, int i, int length) {
    int temp = arr[i];//保存当前节点数据
    //开始调整
    //
    for (int k = 2 * i + 1; k < length; k = k * 2 + 1) {
        //左子节点的值小于右子节点的值
        if (k + 1 < length && arr[k] < arr[k + 1]) {
            k++;//指向右子节点
        }
        //子节点的值大于父节点的值
        if (arr[k] > temp) {
            arr[i] = arr[k];//把较大的值赋值给当前节点
            i = k;//继续调整值较大的子节点
        } else {
            break;//从左至右，从下至上
        }
    }
    //for循环结束后，已经将以i为父节点的值放在了顶上，局部调整好了
    arr[i] = temp;
}
```

## Scanner动态输入解决死循环

```java
public static void main(String[] args) {
    ArrayList<String> stringList = new ArrayList<>();
    Scanner in = new Scanner(System.in);
    //如果是数组就定义一个游标
    while (true) {
        String str = in.nextLine();
        if(str.equals("")){
            break;
        }else {
            stringList.add(str);
        }
    }
    System.out.println(stringList.toString());
}
```

## 一个序列是否是一个入栈序列的出栈序列

```java
public class Solution {
    public boolean IsPopOrder(int [] pushA,int [] popA) {
       //将数组A压栈，如果栈顶元素与数组B的元素相等，然后弹栈，B数组后移。
        Stack<Integer> stack = new Stack<>();
        int i = 0;
        int j = 0;
        while (i<pushA.length){
            stack.push(pushA[i]);
            //栈顶元素与弹出序列的元素相等时
            if (stack.peek() == popA[j]){
                stack.pop();
                j++;
            }
            i++;
        }
        //所有元素已经入栈，继续判断栈顶元素是否等于出栈序列的元素
        while (j<popA.length){
            if(stack.peek() == popA[j]){
                stack.pop();
            }
            j++;
        }
        if (stack.isEmpty())
            return true;
        return false;
    }
}
```

## 比较器的使用

```java
//class TheThing implements Comparable<TheThing> 实现Comparable接口
@Override
public int compareTo(TheThing o) {
    //先比较必要程度
    if (this.biYao < o.biYao) {
        return 1;
    }
    //必要程度相同比较优先级
    if (this.biYao == o.biYao) {
        if (this.youXian < o.youXian) {
            return 1;
        }
    }
    return -1;
}
```

## 判断数组是否是某BST的后序遍历

```java
/**
 * 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。
 * 假设输入的数组的任意两个数字都互不相同。
 */
public class VerifySequenceOfBST {
    public static boolean verifySequenceOfBST(int[] sequence) {
        //对序列不断进行分割，判断所有的右子节点大于根节点，所有左子节点小于根节点
        if (sequence == null || sequence.length == 0) {
            return false;
        }
        return helpVerify(sequence, 0, sequence.length - 1);
    }

    public static boolean helpVerify(int[] sequence, int start, int root) {
        if (start >= root) return true;
        int key = sequence[root];
        int i;
        //找到左右子树的分界点
        for (i = start; i < root; i++)
            if (sequence[i] > key)
                break;
        //在右子树中判断是否含有小于root的值，如果有返回false
        for (int j = i; j < root; j++)
            if (sequence[j] < key)
                return false;
        return helpVerify(sequence, start, i - 1) && helpVerify(sequence, i, root - 1);
    }
}

```

## 求二叉所有到叶子结点的路径和相同的集合

```java
/**
*输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。
*路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。
*/
public class FindPathTreeSum {
    private ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
    private ArrayList<Integer> list = new ArrayList<>();
    public ArrayList<ArrayList<Integer>> FindPath(TreeNode root, int target) {
        if(root == null)
            return result;
        list.add(root.val);
        target = target-root.val;
        //每次找到一个路径就将list集合添加到结果当中去
        if(target == 0 && root.left==null&&root.right==null)
            result.add(new ArrayList<Integer>(list));
        //向左子树和向右子树递归
        FindPath(root.left,target);
        FindPath(root.right,target);
        //在回溯的过程中要将已经添加到list中的节点删除，继续存放兄弟节点
        list.remove(list.size()-1);
        return result;
    }
}
```

## 对复杂链表的深复制

```java
/**
 * 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），
* 请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）
 */
public class CloneComplexList {

    public RandomListNode Clone(RandomListNode pHead) {
        //利用HashMap保存所所有的节点
        HashMap<RandomListNode,RandomListNode> map = new HashMap<>();
        RandomListNode p = pHead;
        while (p!=null){
            RandomListNode newNode = new RandomListNode(p.label);
            map.put(p,newNode);
            p = p.next;
        }
        p = pHead;
        //为新节点赋值
        while (p!=null){
            RandomListNode newNode = map.get(p);
            newNode.next = (p.next == null?null:map.get(p.next));
            newNode.random = (p.random == null?null:map.get(p.random));
            p = p.next;
        }
        return map.get(pHead);
    }
}
 class RandomListNode {
    int label;
    RandomListNode next = null;
    RandomListNode random = null;

    RandomListNode(int label) {
        this.label = label;
    }
}
```

## 二叉搜索树转换为排序的二叉链表

```java
/**
 * 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。
 * 要求不能创建任何新的结点，只能调整树中结点指针的指向。
 */
public class BSTtoDoubleLinkedList {
    //利用一个队列中序遍历二叉树保存节点
    private static Queue<TreeNode> queue = new LinkedList<>();
    public TreeNode Convert(TreeNode pRootOfTree) {
        if(pRootOfTree == null)
            return null;
        midOrder(pRootOfTree);
        TreeNode head = queue.poll();
        TreeNode curr = head;
        while ( !queue.isEmpty()){
            TreeNode node = queue.poll();
            node.left = curr;
            curr.right = node;
            curr = node;
        }
        return head;
    }
    //中序遍历
    public static void midOrder(TreeNode root){
        if(root == null)
            return;
        midOrder(root.left);
        queue.offer(root);
        midOrder(root.right);
    }
}
//递归方法的成员变量
private TreeNode pre;
//递归方法
public TreeNode convertRec(TreeNode pRootOfTree){
    if(pRootOfTree == null)
        return null;
    convertRec(pRootOfTree.right);
    if(pre != null){
        pRootOfTree.right = pre;
        pre.left = pRootOfTree;
    }
    pre = pRootOfTree;
    convertRec(pRootOfTree.left);
    return pre;
}
```

## 字符串的全排列

```java
/*
1、将字符串分为两个部分，第一个字符和后面的所有字符
2、将第一个字符一次和后面的字符进行交换，每次交换就会产生一个新的序列
*/
public static ArrayList<String> permutationHelp(int i , char[] ch, ArrayList<String> res) {
    if(i == ch.length-1){
        String value = String.valueOf(ch);
        if(!res.contains(value)){
            res.add(value);
        }
    }else {
        for (int j = i; j < ch.length; j++) {
            //依次交换
            swap(i,j,ch);
            //进行递归
            permutationHelp(i+1,ch,res);
            //换回来，方便回溯
            swap(i,j,ch);
        }
    }
    return res;
}

private static void swap(int i, int j, char[] ch) {
    char temp = ch[i];
    ch[i] = ch[j];
    ch[j] = temp;
}

public static ArrayList<String> Permutation(String str) {
    ArrayList<String> result = new ArrayList<>();
    if(str!= null || str.length()>0){
        char[] chars = str.toCharArray();
        permutationHelp(0,chars,result);
    }
    return result;
}
```

## 寻找数组中和最大的子序列

```java
/**
 * 在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决.
 * 但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},
 * 连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，
 * 返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)
 */
public class FindMaxSumSubArray {
    public int FindGreatestSumOfSubArray(int[] array) {
        if (array == null || array.length <= 0) {
            return 0;
        }
        int temp = 0;
        int result = 0;
        //如果加上一个数小于零，说明这个数对和不做贡献，舍弃
        for (int k : array) {
            if (temp + k < 0) {
                temp = 0;
            } else {
                temp += k;
            }
            result = Math.max(result, temp);
        }
        //说明所有的元素都小于0
        if (temp != 0) {
            return result;
        }
        //找到数组中元素最大的返回即可
        int maxMember = array[0];
        for (int i = 1; i < array.length; i++) {
            if (array[i] < array[i + 1]) {
                maxMember = array[i + 1];
            }
        }
        return maxMember;
    }
}
```

## 1~n中1出现的次数

通过暴力统计的方法解决该问题，但数据量大的时候效率低下，时间复杂度：On(log.n)

```java
public class Solution {
    public int NumberOf1Between1AndN_Solution(int n) {
        int number = 0;
        //统计每个数的1出现的次数，将结果累加
        for(int i = 1;i <= n ; i++){
            number += numberHelp(i);
        }
        return number;
    }
    //统计一个数当中1出现的次数
    public static int numberHelp(int n){
        int number = 0;
        while(n != 0){
            if(n%10 == 1){
                number++;
            }
            n = n/10;
        }
        return number;
    }
}
```

下面是这道题更巧妙的办法：时间复杂度O（log.n）

```java
public int NumberOf1Between1AndN_Solution(int n) {
    int cnt = 0;
    for(int m = 1;m <= n; m *= 10){
        int a = n / m;
        int b = n % m;
        cnt += ( a + 8 ) / 10 * m + ( a % 10 == 1? b+1:0);
    }
    return cnt;
}
```

## 数组元素能拼接出值最小的数字串

```java
/**
 * 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。
 * 例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。
 */
public class PrintMinNumber {
    
    public static String PrintMinNumber(int[] numbers) {
        if (numbers == null || numbers.length == 0) {
            return "";
        }
        for (int i = 0; i < numbers.length; i++) {
            for (int j = i + 1; j < numbers.length; j++) {
                int sum1 = Integer.valueOf(numbers[i] + "" + numbers[j]);
                int sum2 = Integer.valueOf(numbers[j] + "" + numbers[i]);
                //如果前后相拼接的值比后前相拼接的值大，前后交换
                if (sum1 > sum2) {
                    int temp = numbers[i];
                    numbers[i] = numbers[j];
                    numbers[j] = temp;
                }
            }
        }
        String result = new String();
        for (int number : numbers) {
            result = result + number;
        }
        return result;
    }
}
```

