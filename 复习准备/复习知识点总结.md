# Java当中的深拷贝与浅拷贝

 clone顾名思义就是复制， 在Java语言中， clone方法被对象调用，所以会复制对象。所谓的复制对象，首先要分配一个和源对象同样大小的空间，在这个空间中创建一个新的对象。那么在java语言中，有几种方式可以创建对象呢？
1、使用new操作符创建一个对象
2、使用clone方法复制一个对象
那么这两种方式有什么相同和不同呢？ new操作符的本意是分配内存。程序执行到new操作符时， 首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。而clone在第一步是和new相似的， 都是分配内存，调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域， 填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。 

## 浅拷贝

 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。 

## 深拷贝

 深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。 要实现彻底的深拷贝，就需要将每一个要拷贝对象的内部中的引用数据类型也实现深拷贝。

# DNS解析过程

 浏览器先检查自身缓存中有没有被解析过的这个域名对应的ip地址，如果有，解析结束。 

 如果浏览器缓存中没有（专业点叫还没命中），浏览器会检查操作系统缓存中有没有对应的已解析过的结果。而操作系统也有一个域名解析的过程。在windows中可通过c盘里一个叫hosts的文件来设置，如果你在这里指定了一个域名对应的ip地址，那浏览器会首先使用这个ip地址。 但是这种操作系统级别的域名解析规程也被很多黑客利用，通过修改你的hosts文件里的内容把特定的域名解析到他指定的ip地址上，造成所谓的域名劫持。所以在windows7中将hosts文件设置成了readonly，防止被恶意篡改。  

 如果至此还没有命中域名，才会真正的请求本地域名服务器（LDNS）来解析这个域名，这台服务器一般在你的城市的某个角落，距离你不会很远，并且这台服务器的性能都很好，一般都会缓存域名解析结果，大约80%的域名解析到这里就完成了。 

 如果LDNS仍然没有命中，就直接跳到Root Server 域名服务器请求解析 。

根域名服务器返回给LDNS一个所查询域的主域名服务器（gTLD Server，国际顶尖域名服务器，如.com .cn .org等）地址

此时LDNS再发送请求给上一步返回的gTLD

 接受请求的gTLD查找并返回这个域名对应的Name Server的地址，这个Name Server就是网站注册的域名服务器

Name Server根据映射关系表找到目标ip，返回给LDNS

LDNS缓存这个域名和对应的ip

LDNS把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束。

# TCP/IP

## TCP协议的可靠性

确认和重传：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就重传。

数据校验

数据合理分片和排序：UDP：IP数据报大于1500字节,大于MTU.这个时候发送方IP层就需要分片(fragmentation).把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.这样就会多做许多事情,而更严重的是,由于UDP的特性,当某一片数据传送中丢失时,接收方无法重组数据报.将导致丢弃整个UDP数据报.

tcp会按MTU合理分片，接收方会缓存未按序到达的数据，重新排序后再交给应用层。

流量控制：当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。

拥塞控制：当网络拥塞时，减少数据的发送。

## TCP/IP协议簇

### 应用层

应用层( application-layer ）**的任务是通过应用进程间的交互来完成特定网络应用。**应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。

对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。

### 运输层

运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的**数据传输服务**。应用进程利用该服务传送应用层报文。

运输层主要使用一下两种协议

1. 传输控制协议-TCP：提供面向连接的，可靠的数据传输服务。
2. 用户数据协议-UDP：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。

|              | UDP                                        | TCP                                    |
| ------------ | ------------------------------------------ | -------------------------------------- |
| 是否连接     | 无连接                                     | 面向连接                               |
| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制       | 可靠传输，使用流量控制和拥塞控制       |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信                       |
| 传输方式     | 面向报文                                   | 面向字节流                             |
| 首部开销     | 首部开销小，仅8字节                        | 首部最小20字节，最大60字节             |
| 场景         | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输 |

**每一个应用层（TCP/IP参考模型的最高层）协议一般都会使用到两个传输层协议之一：**

运行在`TCP协议`上的协议：

- `HTTP（Hypertext Transfer Protocol，超文本传输协议）`，主要用于普通浏览。
- `HTTPS（HTTP over SSL，安全超文本传输协议）`,`HTTP`协议的安全版本。
- `FTP（File Transfer Protocol，文件传输协议）`，用于文件传输。
- `POP3（Post Office Protocol, version 3，邮局协议）`，收邮件用。
- `SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）`，用来发送电子邮件。
- `TELNET（Teletype over the Network，网络电传）`，通过一个`终端（terminal）`登陆到网络。
- `SSH（Secure Shell，用于替代安全性差的TELNET）`，用于加密安全登陆用。

运行在`UDP协议`上的协议：

- `BOOTP（Boot Protocol，启动协议）`，应用于无盘设备。
- `NTP（Network Time Protocol，网络时间协议）`，用于网络同步。
- `DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）`，动态配置IP地址。

运行在`TCP`和`UDP`协议上：

- `DNS（Domain Name Service，域名服务）`，用于完成地址查找，邮件转发等工作。

### 网络层

**网络层的任务就是选择合适的网间路由和交换结点，确保计算机通信的数据及时传送。**在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称数据报。

互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。

### 数据链路层

数据链路层(data link layer)通常简称为链路层。**两台主机之间的数据传输**，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。

在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。

在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。

一般的web应用的通信传输流是这样的：

发送端在层与层之间传输数据时，每经过一层时会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时会把对应的首部信息去除。

### 物理层

**在物理层上所传送的数据单位是比特。** 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。

## 三次握手，四次挥手

- `第一次握手`：客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号seq=100。

- `第二次握手`：服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。

- `第三次握手`：客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、seq=101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。

  

- `第一次挥手`：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外FIN报文段即使不携带数据也要占据一个序列号。

- `第二次挥手`：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。

- `第三次挥手`：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)。

- `第四次挥手`：客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。

  ## HTTP状态码

  HTTP状态码表示客户端HTTP请求的返回结果、标识服务器处理是否正常、表明请求出现的错误等。

  状态码的类别：

  | 类别 | 原因短语                                               |
  | ---- | ------------------------------------------------------ |
  | 1XX  | Informational（信息性状态码） 接受的请求正在处理       |
  | 2XX  | Success（成功状态码） 请求正常处理完毕                 |
  | 3XX  | Redirection（重定向状态码） 需要进行附加操作以完成请求 |
  | 4XX  | Client Error（客户端错误状态码） 服务器无法处理请求    |
  | 5XX  | Server Error（服务器错误状态码） 服务器处理请求出错    |

  常用HTTP状态码：

  | 2XX  | 成功（这系列表明请求被正常处理了）                     |
  | ---- | ------------------------------------------------------ |
  | 200  | OK，表示从客户端发来的请求在服务器端被正确处理         |
  | 204  | No content，表示请求成功，但响应报文不含实体的主体部分 |
  | 206  | Partial Content，进行范围请求成功                      |

  | 3XX  | 重定向（表明浏览器要执行特殊处理）                           |
  | ---- | ------------------------------------------------------------ |
  | 301  | moved permanently，永久性重定向，表示资源已被分配了新的 URL  |
  | 302  | found，临时性重定向，表示资源临时被分配了新的 URL            |
  | 303  | see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源（对于301/302/303响应，几乎所有浏览器都会删除报文主体并自动用GET重新请求） |
  | 304  | not modified，表示服务器允许访问资源，但请求未满足条件的情况（与重定向无关） |
  | 307  | temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求 |

  | 4XX  | 客户端错误                                                   |
  | ---- | ------------------------------------------------------------ |
  | 400  | bad request，请求报文存在语法错误                            |
  | 401  | unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息   |
  | 403  | forbidden，表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述 |
  | 404  | not found，表示在服务器上没有找到请求的资源                  |

  | 5XX  | 服务器错误                                                   |
  | ---- | ------------------------------------------------------------ |
  | 500  | internal sever error，表示服务器端在执行请求时发生了错误     |
  | 501  | Not Implemented，表示服务器不支持当前请求所需要的某个功能    |
  | 503  | service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求 |

## Get和Post的区别

说道GET和POST，就不得不提HTTP协议，因为浏览器和服务器的交互是通过HTTP协议执行的，而GET和POST也是HTTP协议中的两种方法。

HTTP全称为Hyper Text Transfer Protocol，中文翻译为超文本传输协议，目的是保证浏览器与服务器之间的通信。HTTP的工作方式是客户端与服务器之间的请求-应答协议。

HTTP协议中定义了浏览器和服务器进行交互的不同方法，基本方法有4种，分别是GET，POST，PUT，DELETE。这四种方法可以理解为，对服务器资源的查，改，增，删。

- GET：从服务器上获取数据，也就是所谓的查，仅仅是获取服务器资源，不进行修改。
- POST：向服务器提交数据，这就涉及到了数据的更新，也就是更改服务器的数据。
- PUT：英文含义是放置，也就是向服务器新添加数据，就是所谓的增。
- DELETE：从字面意思也能看出，这种方式就是删除服务器数据的过程。



**区别：**

1. Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。 但是这种做法也不时绝对的，大部分人的做法也是按照上面的说法来的，但是也可以在get请求加上 request body，给 post请求带上 URL 参数。

2. Get请求提交的url中的数据最多只能是2048字节，这个限制是浏览器或者服务器给添加的，http协议并没有对url长度进行限制，目的是为了保证服务器和浏览器能够正常运行，防止有人恶意发送请求。Post请求则没有大小限制。

3. Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。

4. Get执行效率却比Post方法好。Get是form提交的默认方法。

5. GET产生一个TCP数据包；POST产生两个TCP数据包。

   对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

   而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

# BIO、NIO、AIO的区别

简答

- BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。
- NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。
- AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。

详细回答

- **BIO (Blocking I/O):** 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。
- **NIO (New I/O):** NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 `Socket` 和 `ServerSocket` 相对应的 `SocketChannel` 和 `ServerSocketChannel` 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发
- **AIO (Asynchronous I/O):** AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。

# 对象的创建过程

## java 创建对象的方式

1. 使用new关键字，调用了构造函数
2. 使用Class的newInstance方法，调用了构造函数
3. 使用Constructor类的newInstance方法，调用了构造方法
4. 使用clone方法，没有调用构造函数
5. 使用反序列化，没有调用构造函数

## 对象创建过程

1. 当虚拟机遇到一条new指令时， 先检查常量池是否已经加载相应的类，如果没有，必须先执行相应的类加载。类加载通过后，接下来分配内存。 
2.  若Java堆中内存是绝对规整的，使用“指针碰撞“方式分配内存；如果不是规整的，就从空闲列表中分配，叫做”空闲列表“方式。 
3.  划分内存时还需要考虑一个问题-并发，也有两种方式: CAS同步处理，或者本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。
   1. 对分配内存空间的动作进行同步处理（采用 `CAS` + 失败重试来保障更新操作的原子性）；
   2. 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配。只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁。通过-XX:+/-UserTLAB参数来设定虚拟机是否使用TLAB。 
4.  然后内存空间初始化操作，接着是做一些必要的对象设置(元信息、哈希码…)，最后执行`<init>`方法。

# Java中的内存泄露

 java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。 

# Java中的垃圾标记算法

- 引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；
- 可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。

# JVM的垃圾回收算法

- 标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。
- 复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。
- 标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。
- 分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。

## 标记-清除算法

标记无用对象，然后进行清除回收。

标记-清除算法（Mark-Sweep）是一种常见的基础垃圾收集算法，它将垃圾收集分为两个阶段：

- 标记阶段：标记出可以回收的对象。
- 清除阶段：回收被标记的对象所占用的空间。

标记-清除算法之所以是基础的，是因为后面讲到的垃圾收集算法都是在此算法的基础上进行改进的。

**优点**：实现简单，不需要对象进行移动。

**缺点**：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。

## 复制算法

为了解决标记-清除算法的效率不高的问题，产生了复制算法。它把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中，最后将当前使用的区域的可回收的对象进行回收。

**优点**：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。

**缺点**：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。

## 标记-整理算法

在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为老年代的对象存活率会较高，这样会有较多的复制操作，导致效率变低。标记-清除算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎片。因此就出现了一种标记-整理算法（Mark-Compact）算法，与标记-整理算法不同的是，在标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进行回收。回收后，已用和未用的内存都各自一边。

**优点**：解决了标记-清理算法存在的内存碎片问题。

**缺点**：仍需要进行局部对象移动，一定程度上降低了效率。

## 分代收集算法

当前商业虚拟机都采用**分代收集**的垃圾收集算法。分代收集算法，顾名思义是根据对象的**存活周期**将内存划分为几块。一般包括**年轻代**、**老年代** 和 **永久代**，如图所示：

 ![img](https://img-blog.csdnimg.cn/20200104120144820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70) 

## GCROOT

 1、所有Java线程当前栈帧引用的，也就是正在被调用的方法的引用类型的参数、局部变量以及临时值。
2、所有的静态数据结构引用的对象
3、String常量池里的引用
4、运行时常量池里引用的类型 

 ## CMS

每种收集器都有各自的优势，  CMS收集器是为了低延迟而生，通过尽可能的并行执行垃圾回收的几个阶段来把延迟控制到最低。CMS收集器是老年代的垃圾收集器，一般情况下会有ParNew来配合执行(默认情况下也是ParNew)，ParNew也是使用并行的算法来执行年轻代的回收。 

CMS的四大步骤：

​	初始标记： 一是遍历GCRoot可直达的老年代对象；二是遍历新生代直达的老年代对象。这里的直达是指直接关联到GCRoot的一级对象。初始标记阶段是完全STW的，应用程序会暂停。 

并发标记：对初始标记中标记的存活对象进行trace，标记这些对象为可达对象，例如A->B，A在初始标记被识别，而B就是在并发标记阶段被识别。

将在并发阶段新生代晋升到老年代的对象、直接在老年代分配的对象以及老年代引用关系发生变化的对象所在的card标记为dirty，避免在重新标记阶段扫描整个老年代。三色标记法。

​	重新标记：STW，修正并发期间因为用户线程工作而产生变动的那一部分对象

​	并发清除 ：清除已标记的对象，耗时长。

CMS优点：并发收集，低停顿，需要STW的步骤耗时较短。

CMS缺点：对CPU资源敏感；无法处理浮动垃圾，会产生空间碎片。

# String类

## String类定义

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
```

string类被声明为**静态**的类，其中用char数据进行值的保存。

## 重要构造器

```java
//无参构造器是默认产生一个空串
public String() {
    this.value = "".value;
}
//传入的是一个字符串的引用，直接复制字符串的值和hash
public String(String original) {
    this.value = original.value;
    this.hash = original.hash;
}
//传入一个字符数组直接赋值
public String(char value[]) {
    this.value = Arrays.copyOf(value, value.length);
}
//加同步监视器的构造器，若传入的是StringBuilder则通过Arrays工具类的值复制方法进行构造
public String(StringBuffer buffer) {
    synchronized(buffer) {
        this.value = Arrays.copyOf(buffer.getValue(), buffer.length());
    }
}
```

## equals方法

```java
public boolean equals(Object anObject) {
    	//首先比较地址，是不是同一个对象
        if (this == anObject) {
            return true;
        }
    	//instanceof用来判断前者的类型是不是后者，用来做类型判断
        if (anObject instanceof String) {
            String anotherString = (String)anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                //每个字符都进行比较
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }
```

## subString方法

```java
public String substring(int beginIndex) {
    if (beginIndex < 0) {
        throw new StringIndexOutOfBoundsException(beginIndex);
    }
    int subLen = value.length - beginIndex;
    if (subLen < 0) {
        throw new StringIndexOutOfBoundsException(subLen);
    }
    //返回的是新创建的一个对象
    return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);
}
```

## String中本地方法intern()方法

```java
public class Test3 {
    public static void main(String[] args) {
        String s1 = "he";
        String s2 = "llo";
        String s3 = s1+s2;//新创建了一个对象
        String s4 = "hello";
        String s5 = s4;//直接吧s4的引用给s5

        String s6 = new String("hello").intern();
        String s7 = s3.intern();

        System.out.println(s5 == s4);//true
        System.out.println(s3 == s4);//false
        System.out.println(s3.equals("hello"));//true

        System.out.println(s6 == s4);//true
        System.out.println(s7 == s3);//false
        System.out.println(s7 == s4);//true
    }
}
```

**intern 这个方法返回的是 返回字符串对象的规范化表示形式，当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（该对象由 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并且返回此 String 对象的引用。**

# MySQL相关问题

## 索引的本质

索引（Index）是帮助MySQL高效获取数据的数据结构。索引是数据库维护数据之外的另外一种数据结构，基于这些数据结构可以实现更高级的查找算法。这种数据结构，就是索引。**由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。**索引的性能一般与索引的结构有关，由于索引也是存在索引文件当中的，所以每次IO操作的时间和复杂度就是多索引性能的评价。因此MySQL主要使用的是B+树作为索引。

## MyISAM索引实现

MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是**数据记录的地址。** **非聚集**的索引。查找数据时，首先先根据索引找到相应叶节点，取出叶节点所存放的地址，根据地址再去读取数据。

## InnoDB索引实现

第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此**InnoDB表数据文件本身就是主索引。**叶节点包含了完整的数据记录，这种索引就是**聚集索引。**

第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的**所有辅助索引都引用主键作为data域**。

## InnoDB主键建议

不推荐使用过长的字段作为主键，因为辅助索引都是引用主键的值，主键过长会导致辅助索引过于庞大。

推荐单调连续的值作为主键，如果不连续会导致维护索引时频繁分裂B+树进行数据表的调整。

## 最左前缀与相关优化

1. **全列匹配：**当按照索引中所有列进行精确匹配（这里精确匹配指**“=”或“IN”**匹配）时，索引可以被用到。
2. 最左前缀匹配：当查询条件精确匹配索引的左边连续一个或几个列时，如<emp_no>或<emp_no, title>，所以可以被用到，但是只能用到一部分，即条件所组成的最左前缀。
3. 查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。也只会用到最前面的索引列。在这种成为“坑”的列值比较少的情况下，可以考虑用**“IN”**来填补这个“坑”从而形成最左前缀
4. 查询条件没有指定索引第一列。
5. 匹配某列的前缀字符串。如果通配符%不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀。
6. 范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。
7. 如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引4

## MySQL连接多个表

对于三张表或者以上，连接n个表至少需要n-1个条件，避免笛卡尔积的出现。

## 数据库设计的三大原则

1. 数据库每列具有原子性（所有字段都是不可分解的原子），行不可重复，列不可再分。
2. 确保非主键列必须完全依赖主键列，不能部分依赖(通常对联合组件来说)
3. 确保每列值都和主键列直接相关而不是部分相关（非主键列不能相互依赖）

## MySQL事务

事务的四大特性（ACID）

**原子性（Atomicity）**：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

**一致性（Consistency）**：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。

**隔离性（isolation）**：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

**持久性（durable）**：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

## MySQL事务的隔离级别

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 |
| ---------------------------- | ---- | ---------- | ---- |
| 读未提交（read-uncommitted） | 是   | 是         | 是   |
| 不可重复读（read-committed） | 否   | 是         | 是   |
| 可重复读（repeatable-read）  | 否   | 否         | 是   |
| 串行化（serializable）       | 否   | 否         | 否   |

## 事务的并发问题

　　1、**脏读**：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据

　　2、**不可重复读**：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。

　　3、**幻读**：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

​		4、**丢失更新**：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题－－最后的更新覆盖了由其他事务所做的更新。

　　小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。**解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表**

## MySQL的存储引擎

### MyISAM

它是MySQL5.5之前的默认存储引擎，**优势是访问速度快**。**适用场景**：对事务的完整性没有要求，或以select、insert为主的应用基本都可以选用MYISAM。在Web、数据仓库中应用广泛。

特点：

1. 不支持事务、外键。

2. 数据文件和索引文件可以放在不同的目录，平均分布IO，加快访问速度。

3. 三种不同的存储格式：静态表、动态表、压缩表。


### InnoDB

MySQL5.5之后的默认存储引擎。

**应用场景**：如果应用对事务的完整性有较高的要求，在并发条件下要求数据的一致性，数据操作中包含读、插入、删除、更新，那InnoDB是最好的选择。在计费系统、财务系统等对数据的准确性要求较高的系统中被广泛应用。

**优点**：提供了具有提交（Commit）、回滚（Rollback）、崩溃恢复能力的事务安全，支持外键。

**缺点**：相比较于MyISAM，写的处理效率差一点，并且会占用更多的磁盘空间来存储数据和索引。

### MEMORY

MEMORY存储引擎是用**保存在内存中的数据**来创建表，每个memory表对应一个磁盘文件。格式是.frm。

**特点**：由于他的数据是存放在内存中的，并且默认使用HASH索引，所以它的访问速度特别快。

**缺点**：就是数据库服务一旦关闭，数据就会丢失，另外对表的大小有限制。

![image-20200921120303667](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200921120303667.png)



## 数据库中的锁

在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

### 锁的分类

从对数据操作的类型（读\写）分可分为：

**读锁(共享锁)**：针对同一份数据，多个读操作可以同时进行而不会互相影响。

**写锁（排它锁）**：当前写操作没有完成前，它会阻断其他写锁和读锁。

从对数据的操作粒度分：

**表锁**：偏读。偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。  

1、对MyISAM表的读操作（加读锁），不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。 
2、对MyISAM表的写操作（加写锁），会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。
简而言之，就是**读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞**。

**行锁**：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。

**页锁**：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。了解即可。

**InnoDB行锁实现方式：**InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：**只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。**

**间隙锁**：当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。

**间隙锁的危害**：间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害。

### 锁的优化建议

1. 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。
2. 尽可能较少检索条件，避免间隙锁。
3. 尽量控制事务大小，减少锁定资源量和时间长度。
4. 锁住某行后，尽量不要去调别的行或表，赶紧处理被锁住的行然后释放掉锁。
5. 涉及相同表的事务，对于调用表的顺序尽量保持一致。
6. 在业务环境允许的情况下,尽可能低级别事务隔离
7. 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

## MySQL中的主从复制

**MySQL复制过程分成三步：**

1 master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events；
2 slave将master的binary log events拷贝到它的中继日志（relay log）；
3 slave重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的。

**复制的基本原则：**

1. 每个slave只有一个master。
2. 每个slave只能有一个唯一的服务器ID。
3. 每个master可以有多个salve。

# 集合框架

## Collection接口

Collection接口下常用的容器有：ArrayList、LinkedList、Queue、vector、stack、Set接口

Collection接口实现了Iterable接口，方便对容器元素的遍历。

## ArrayList类

继承关系

![image-20200922202048396](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200922202048396.png)

ArrayList源码分析：

```java
//默认第一次添加后的长度为10
private static final int DEFAULT_CAPACITY = 10;
//初始化为Object类型的空数组
private static final Object[] EMPTY_ELEMENTDATA = {};
//初始化长度为10的数组依然是空数组
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
```

构造器：

```java
public ArrayList(int initialCapacity) {
    if (initialCapacity > 0) {
        //大于0初始化显示指定的长度
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {
        //等于0为空数组
        this.elementData = EMPTY_ELEMENTDATA;
    } else {
        //长度不合法
        throw new IllegalArgumentException("Illegal Capacity: "+
                                           initialCapacity);
    }
}
//不指定长度依然是空数组
public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
```

扩容：

```java
private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
    	//每一次扩容为原来的1.5倍
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // 采用复制的方法进行扩容，newCapacity是新数组的长度
        elementData = Arrays.copyOf(elementData, newCapacity);
}
```

添加元素：

```java
public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}
//首次添加size已经为1
private void ensureCapacityInternal(int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        //minCapacity 为10
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }

    ensureExplicitCapacity(minCapacity);
}
//进行第一次扩容，长度为10
private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    // overflow-conscious code
    if (minCapacity - elementData.length > 0)
        grow(minCapacity);
}
```

删除：

```java
public E remove(int index) {
    //检查索引是否合法
    rangeCheck(index);
	
    modCount++;
    //获取旧值
    E oldValue = elementData(index);
	//size-1
    int numMoved = size - index - 1;
    if (numMoved > 0)
        //还是用到了数组的复制
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    elementData[--size] = null; // clear to let GC do its work
	//返回旧值
    return oldValue;
}
```

## LinkedList类

类图继承关系

![image-20200922204139344](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200922204139344.png)

LinkedList底层维护了一个双向链表，其具体代码如下：

```java
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;

    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```

其他的操作基本就是关于链表的操作。**ArrayList和LinkedList的区别主要是底层的数据结构不同，因此前者偏向于读操作，后者更偏向于写操作，效率会更高。**

## Queue接口

主要的具体实现在其子类中，常用的有很多，具体参考源码。队列的主要特性就是先进先出（FIFO）。

## Vector

vector的类图具体如下：

![image-20200922205455374](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200922205455374.png)

源码分析：

```java
//底层采用数组
protected Object[] elementData;
//构造器，默认的初始化长度为10，
public Vector() {
        this(10);
    }
public Vector(int initialCapacity) {
        this(initialCapacity, 0);
    }
public Vector(int initialCapacity, int capacityIncrement) {
    super();
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal Capacity: "+
                                           initialCapacity);
    this.elementData = new Object[initialCapacity];
    //capacityIncrement为指定每次扩容增加的容量，默认扩容为原来的2倍
    this.capacityIncrement = capacityIncrement;
}
```

扩容：

```java
private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    //判断采取是否采用默认的扩容机制还是增加指定容量
    int newCapacity = oldCapacity + ((capacityIncrement > 0) ?
                                     capacityIncrement : oldCapacity);
    //如果扩容之后还是放不下，直接扩容至添加后的容量
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    //如果超出限制，直接抛OOM异常
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

在vector中好多方法都是添加了**synchronized关键字**进行修饰的，因此vector被称为线程安全的容器，在效率相关的条件下可以进行选择。

## Set接口

Set接口也是实现了Collection接口的一个容器接口，首先看一些类的继承关系。

![image-20200929162340594](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200929162340594.png)

常用的实现类主要有HashSet和TreeSet。下面就来具体探究一下HashSet和TreeSet的具体实现。

### HashSet

```java
//底层采用HashMap来保存数据，具体使用的是HashMap的key
private transient HashMap<E,Object> map;
//默认的构造器是直接new了一个HashMap，默认大小是16，加载因子是0.75
public HashSet() {
        map = new HashMap<>();
}
//指定初始容量和默认加载因子
public HashSet(int initialCapacity, float loadFactor) {
        map = new HashMap<>(initialCapacity, loadFactor);
}
//迭代器方法被重写，返回了map的键集合的迭代器
public Iterator<E> iterator() {
    return map.keySet().iterator();
}
//添加方法，使用的是map的put方法，值为一个Object对象，无具体意义
//可以看见是讲传进的参数当成map的key，也因此需要对传进的参数重写equals（）方法。
//由此可以得出，set是不能存放相同元素的。
public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}
```

### TreeSet

```java
//将TreeMap赋值给 "NavigableMap对象m"
TreeSet(NavigableMap<E,Object> m) {
    this.m = m;
}
//不带参数的构造函数。创建一个空的TreeMap
public TreeSet() {
    this(new TreeMap<E,Object>());
}
// 带比较器的构造函数。
public TreeSet(Comparator<? super E> comparator) {
    this(new TreeMap<E,Object>(comparator));
}

// 创建TreeSet，并将集合c中的全部元素都添加到TreeSet中
public TreeSet(Collection<? extends E> c) {
    this();
    // 将集合c中的元素全部添加到TreeSet中
    addAll(c);
}

// 创建TreeSet，并将s中的全部元素都添加到TreeSet中
public TreeSet(SortedSet<E> s) {
    this(s.comparator());
    addAll(s);
}
 
// 返回TreeSet的顺序排列的迭代器。
// 因为TreeSet时TreeMap实现的，所以这里实际上时返回TreeMap的“键集”对应的迭代器
public Iterator<E> iterator() {
    return m.navigableKeySet().iterator();
}

// 返回TreeSet的逆序排列的迭代器。
// 因为TreeSet时TreeMap实现的，所以这里实际上时返回TreeMap的“键集”对应的迭代器
public Iterator<E> descendingIterator() {
    return m.descendingKeySet().iterator();
}

// 将集合c中的全部元素添加到TreeSet中
public  boolean addAll(Collection<? extends E> c) {
    // Use linear-time version if applicable
    if (m.size()==0 && c.size() > 0 &&
        c instanceof SortedSet &&
        m instanceof TreeMap) {
        SortedSet<? extends E> set = (SortedSet<? extends E>) c;
        TreeMap<E,Object> map = (TreeMap<E, Object>) m;
        Comparator<? super E> cc = (Comparator<? super E>) set.comparator();
        Comparator<? super E> mc = map.comparator();
        if (cc==mc || (cc != null && cc.equals(mc))) {
            map.addAllForTreeSet(set, PRESENT);
            return true;
        }
    }
    return super.addAll(c);
}
```

## Map接口

map接口是对与Collection接口的，他的继承与实现关系如下图：

![image-20200929170949384](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200929170949384.png)

### HashMap

```java
public class HashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable {
12
```

HashMap<K,V>继承了AbstractMap<K,V>，并且实现了Map<K,V>, Cloneable, Serializable接口，表明HashMap可以复制，也可以序列化。

初始容量

```java
    /**
     * The default initial capacity - MUST be a power of two.
     */
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16

```

HashMap的默认初始化容量是16。

最大容量

```java
    /**
     * The maximum capacity, used if a higher value is implicitly specified
     * by either of the constructors with arguments.
     * MUST be a power of two <= 1<<30.
     */
    static final int MAXIMUM_CAPACITY = 1 << 30;

```

HashMap的最大容量是2的30 次方。

默认加载因子

```java
    /**
     * The load factor used when none specified in constructor.
     */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;

```

默认加载因子是0.75，为什么是0.75？
如果加载因子过小，那么会频繁进行扩容操作，扩容也会带来性能上的消耗，而加载因子过大，会大大增加hash冲突的概率，从而影响性能。

还有几个常量，此处我们先记住它们，后面会用到。

```java
  	static final int TREEIFY_THRESHOLD = 8;

	static final int UNTREEIFY_THRESHOLD = 6;
  	
    static final int MIN_TREEIFY_CAPACITY = 64;


```

结点声明

```java
static class Node<K,V> implements Map.Entry<K,V> 

```

是一个node结点。
那么来看看它有哪些东西

```java
 final int hash;
        final K key;
        V value;
        Node<K,V> next;
        
        public final K getKey()        { return key; }
        
        public final V getValue()      { return value; }

        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

        public final V setValue(V newValue) {
			//省略
        }

        public final boolean equals(Object o) {
            //方法体暂时不看
    }
```

put方法

```java
public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
```

显然从这里看不到具体细节，直接上putVal(hash(key), key, value, false, true)源码

```java
final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {

        Node<K,V>[] tab;
        Node<K,V> p;
        int n, i;
        //当底层的数组为空时，就会进行第一次扩容
        if ((tab = table) == null || (n = tab.length) == 0)
        //resize()为实际的扩容方法
            n = (tab = resize()).length;
        //判断当前要存放的位置是否有值
        if ((p = tab[i = (n - 1) & hash]) == null)
        //没有值就直接存储
            tab[i] = newNode(hash, key, value, null);
        else {
            Node<K,V> e; K k;
            //判断要存放的值和原来位置上已有的值的哈希值是否相等
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                //哈希相等并且通过equals比较值也相等，将待存的元素放到e中
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else {//如果此位置上是链表结构，还要和每一个元素进行比较，直接循环
                for (int binCount = 0; ; ++binCount) {
                	//如果发现该位置就只有一个p元素
                    if ((e = p.next) == null) {
                    //直接尾插法插入该节点
                        p.next = newNode(hash, key, value, null);
                        //将链表转换成红黑树的情况，链表长度大于等于8
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    //p.next存在，就进行hash值和equals的比较。
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        //相等就退出去，进行替换
                        break;
                        //循环控制
                    p = e;
                }
            }
            //如果e!= null 说明已经有一个key了，将它的旧值进行返回并用新值覆盖原来的旧值
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size > threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
```

resize方法

```java
final Node<K,V>[] resize() {
        Node<K,V>[] oldTab = table;
        //第一次扩容，oldtable为null，赋值为0
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap > 0) {
            if (oldCap >= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                     oldCap >= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr << 1; // double threshold
        }
        else if (oldThr > 0) // initial capacity was placed in threshold
            newCap = oldThr;
        else {               // zero initial threshold signifies using defaults
        	//初始化新数组的长度为16
            newCap = DEFAULT_INITIAL_CAPACITY;
            //16*0.75 需要扩容的阈值12出现
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        @SuppressWarnings({"rawtypes","unchecked"})
        //newCap为16，初始化新数组
        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
        //将造好的数组给table
        table = newTab;
        if (oldTab != null) {
            for (int j = 0; j < oldCap; ++j) {
                Node<K,V> e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash & (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                    else { // preserve order
                        Node<K,V> loHead = null, loTail = null;
                        Node<K,V> hiHead = null, hiTail = null;
                        Node<K,V> next;
                        do {
                            next = e.next;
                            if ((e.hash & oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }
```

转化成红黑树的方法

```java
final void treeifyBin(Node<K,V>[] tab, int hash) {
        int n, index; Node<K,V> e;
        if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
        //当前数组的长度小于64，那就去扩容，不要构成树结构
            resize();
        else if ((e = tab[index = (n - 1) & hash]) != null) {
            TreeNode<K,V> hd = null, tl = null;
            do {
                TreeNode<K,V> p = replacementTreeNode(e, null);
                if (tl == null)
                    hd = p;
                else {
                    p.prev = tl;
                    tl.next = p;
                }
                tl = p;
            } while ((e = e.next) != null);
            if ((tab[index] = hd) != null)
                hd.treeify(tab);
        }
    }
```

通过以上源码的大致分析，可以总结一下几点：

1. HashMap在jdk1.8中采用的是数组加链表加红黑树的方式，而在jdk1.7中采用的是数组加链表的方式。

2. 初始化时并没有直接创建数组，而是在第一次put的时候去创建数组。

3. 链表转化红黑树的时机：链表长度大于等于8，并且数组的长度大于64。

4. 初始容量为16，默认加载因子0.75，每次扩容为原来的2倍。

5. 可以有一个null键，可以有多可null值。

6. 线程不安全。

   

# 生产者和消费者

## wait() 和 notify()实现

```java
import java.util.Queue;
import java.util.concurrent.ArrayBlockingQueue;

public class TestPC {
    //定义队列的大小
    public static final int MAX_POOL = 10;
    //生产者现成的个数
    public static final int MAX_PRODUCER = 5;
    //消费者线程的个数
    public static final int MAX_CONSUMER = 6;
    //队列用于二者之间的消息中间件
    public static Queue<Goods> queue = new ArrayBlockingQueue<>(MAX_POOL);

    public static void main(String[] args) {
        Producer producer = new Producer();
        Consumer consumer = new Consumer();

        for (int i = 0; i < MAX_PRODUCER; i++) {
            Thread threadA = new Thread(producer, "生产者线程" + i);
            threadA.start();
        }

        for (int i = 0; i < MAX_CONSUMER; i++) {
            Thread threadB = new Thread(consumer, "消费者线程" + i);
            threadB.start();
        }
    }
}
```

```java
public class Goods {
    private int id;
    private String name;

    public Goods(int id, String name) {
        this.id = id;
        this.name = name;
    }
}
```

```java
public class Producer extends Thread {
    private Goods goods;
    @Override
    public void run() {
        while (true){
            try {
                Thread.sleep(1000);

            }catch (InterruptedException e){
                e.printStackTrace();
            }
            //对队列进行同步
            synchronized (TestPC.queue){
                goods = new Goods(1,"商品");
                //如果队列还有空间就继续生产
                if(TestPC.queue.size()<TestPC.MAX_POOL){
                    TestPC.queue.add(goods);
                    System.out.println(Thread.currentThread().getName()+"生产商品");
                }else {
                    //没有空间让生产者进行等待
                    try {
                        TestPC.queue.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
}
```

```java
public class Consumer extends Thread {
    @Override
    public void run() {
        while (true){
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (TestPC.queue){
                if(!TestPC.queue.isEmpty()){//队列中有商品
                    TestPC.queue.poll();
                    System.out.println(Thread.currentThread().getName()+"消费商品");
                }else {
                    //唤醒生产者（等待的线程）继续生产
                    TestPC.queue.notify();
                }
            }
        }
    }
}
```

wait() 和 notify() 的另一种实现

```java
import java.util.LinkedList;

public class ProAndCon {
    private static int MAXSIZE = 5;
    private static LinkedList<Integer> list = new LinkedList<>();

    class Producer implements Runnable{
        @Override
        public void run() {
            synchronized(list){
                //缓存无剩余空间
                while (list.size() == MAXSIZE){
                    try {
                        list.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                list.add(1);
                System.out.println(Thread.currentThread().getName()+"生产者生产产品,仓库容量为："+list.size());
                list.notify();
            }
        }
    }
    class Consumer implements Runnable{
        @Override
        public void run() {
            synchronized (list){
                while (list.isEmpty()){
                    System.out.println("仓库为空！");
                    try {
                        list.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                list.removeFirst();
                System.out.println(Thread.currentThread().getName()+"消费者消费产品，剩余容量为："+list.size());
                list.notify();
            }
        }
    }

    public static void main(String[] args) {
        ProAndCon proAndCon = new ProAndCon();
        Producer producer = proAndCon.new Producer();
        Consumer consumer = proAndCon.new Consumer();
        for (int i = 0; i < 10; i++) {
            Thread pro = new Thread(producer);
            pro.start();
            Thread con = new Thread(consumer);
            con.start();
        }
    }
}
```

## 独占锁加条件变量实现

产品类

```java
import java.util.LinkedList;
import java.util.Queue;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 仓库，负责存储商品
 */
public class Storage {
    private static int MAX_SIZE = 10;
    //用来模拟商品，使用队列作为缓冲
    private Queue<Integer> queue = new LinkedList<>();
    private ReentrantLock lock = new ReentrantLock();
    private Condition fullCondition = lock.newCondition();
    private Condition emptyCondition = lock.newCondition();
    private int index = 0;

    //生产商品的方法
    public void produce() {
        try {
            lock.lock();
            if (queue.size() >= MAX_SIZE) {
                System.out.println("仓库已满，停止生产！");
                fullCondition.await();
            }
            Thread.sleep(500);
            queue.add(index++);
            System.out.println(index + "号产品生产了！");
            //发送信号量通知消费者进行消费
            emptyCondition.signal();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    //消费商品的方法
    public void consumer() {
        try {
            lock.lock();
            if (queue.isEmpty()) {
                //没有商品，等待，通知生产
                System.out.println("仓库为空！");
                emptyCondition.await();
            }
            Thread.sleep(500);
            queue.poll();
            System.out.println("产品被消费了一个！仓库剩余量为：" + queue.size());
            //通知生产者生产
            fullCondition.signal();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```

生产者

```java
public class Producer extends Thread {
    private Storage storage;

    public Producer(Storage storage) {
        this.storage = storage;
    }
    
    @Override
    public void run() {
        while (!Thread.interrupted()){
            storage.produce();
        }
    }
}
```

消费者

```java
public class Consumer extends Thread {
    private Storage storage ;

    public Consumer(Storage storage) {
        this.storage = storage;
    }

    @Override
    public void run() {
        while (!Thread.interrupted()){
            storage.consumer();
        }
    }
}
```

测试主函数

```java
public class Test {
    public static void main(String[] args) {
        Storage storage = new Storage();
        Producer producer = new Producer(storage);
        Consumer consumer = new Consumer(storage);
        producer.start();
        consumer.start();
    }
}
```

## 阻塞队列实现生产者和消费者

仓库类

```java
import java.util.concurrent.LinkedBlockingQueue;

public class Storage {
    //容量为10的队列作为缓存
    private LinkedBlockingQueue<Object> queue = new LinkedBlockingQueue(10);
    int number = 0;

    public void produce() {
        while (true){
            try {
                Thread.sleep(500);
                //容量满了时也自动阻塞
                queue.put(number++);
                System.out.println("生产了一个产品！容量为：" + queue.size());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }

    public void consumer() {
        while (true){
            try {
                Thread.sleep(800);
                //take方法容量为空时自动阻塞
                System.out.println("消费了产品"+queue.take()+",容量为：" + queue.size());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

生产者

```java
public class Producer  extends Thread{
    private Storage storage;

    public Producer(Storage storage) {
        this.storage = storage;
    }

    @Override
    public void run() {
        storage.produce();
    }
}
```

消费者

```java
public class Consumer extends Thread {
    private Storage storage;

    public Consumer(Storage storage) {
        this.storage = storage;
    }

    @Override
    public void run() {
        storage.consumer();
    }
}
```

测试主函数

```java
public class Test {
    public static void main(String[] args) {
        Storage storage = new Storage();
        Producer producer = new Producer(storage);
        Consumer consumer = new Consumer(storage);
        producer.start();
        consumer.start();
    }
}
```

# 三个线程交替打印ABC

## wait() 和 notifyAll() 方法实现

```java
/**
 * 使用wait函数和notifyAll函数实现交替打印 ABC
 */
public class Print_W_N {
    //静态内部类用来实现打印功能
    public static class ThreadPrint implements Runnable{
        private String name;
        private Object prev;
        private Object self;

        public ThreadPrint(String name, Object prev, Object self) {
            this.name = name;
            this.prev = prev;
            this.self = self;
        }

        @Override
        public void run() {
            int count = 10;
            while (count > 0){
                //拿到前一个对象的锁
                synchronized (prev){
                    //拿到自身的锁
                    synchronized (self){
                        System.out.println(name);
                        count--;
                        self.notifyAll();//唤醒其他线程竞争self锁，此时锁并没有立即释放
                    }
                    try {
                        if (count == 0){
                            //如果是最后一次打印，通过notifyAll操作释放对象锁
                            prev.notifyAll();
                        }else {
                            //立即释放prev锁，当前线程休眠等待唤醒
                            prev.wait();
                        }
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Object a = new Object();
        Object b = new Object();
        Object c = new Object();
        ThreadPrint pa = new ThreadPrint("A",c,a);
        ThreadPrint pb = new ThreadPrint("B",a,b);
        ThreadPrint pc = new ThreadPrint("C",b,c);
        //添加sleep函数保证线程的启动顺序
        new Thread(pa).start();
        Thread.sleep(100);
        new Thread(pb).start();
        Thread.sleep(100);
        new Thread(pc).start();
        Thread.sleep(100);
    }
}
```

 ## 使用lock和state标志

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 使用lock和state标志进行交替打印
 */
public class Print_Lock_State {
    private static Lock lock = new ReentrantLock();
    private static int state = 0;//通过state的值来确定是哪个线程来打印

    static class ThreadA extends Thread {
        @Override
        public void run() {
            for (int i = 0; i < 10; ) {
                try {
                    lock.lock();
                    while (state % 3 == 0) {//多线程环境下，使用while进行循环检测，避免虚假唤醒
                        System.out.println("A");
                        state++;
                        i++;
                    }
                } finally {
                    lock.unlock();
                }
            }
        }
    }

    static class ThreadB extends Thread {
        @Override
        public void run() {
            for (int i = 0; i < 10; ) {
                try {
                    lock.lock();
                    while (state % 3 == 1) {
                        System.out.println("B");
                        state++;
                        i++;
                    }
                } finally {
                    lock.unlock();
                }
            }
        }
    }

    static class ThreadC extends Thread {
        @Override
        public void run() {
            for (int i = 0; i < 10; ) {
                try {
                    lock.lock();
                    while (state % 3 == 2) {
                        System.out.println("C");
                        state++;
                        i++;
                    }
                } finally {
                    lock.unlock();
                }
            }
        }
    }

    public static void main(String[] args) {
        new ThreadA().start();
        new ThreadB().start();
        new ThreadC().start();
    }
}
```

## 通过原子类实现

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicInteger;

public class Print_AtomicInteger {
    private AtomicInteger camp = new AtomicInteger(0);
    private static final int MAX_VALUE = 3 * 10;

    private class ThreadA implements Runnable {
        @Override
        public void run() {
            while (camp.get() < MAX_VALUE - 1) {
                if (camp.get() % 3 == 0) {
                    System.out.println("A");
                    //让值自增1
                    camp.getAndIncrement();
                }
            }
        }
    }

    private class ThreadB implements Runnable {
        @Override
        public void run() {
            while (camp.get() < MAX_VALUE) {
                if (camp.get() % 3 == 1) {
                    System.out.println("B");
                    //让值自增1
                    camp.getAndIncrement();
                }
            }
        }
    }

    private class ThreadC implements Runnable {
        @Override
        public void run() {
            while (camp.get() < MAX_VALUE) {
                if (camp.get() % 3 == 2) {
                    System.out.println("C");
                    //让值自增1
                    camp.getAndIncrement();
                }
            }
        }
    }

    public static void main(String[] args) {
        Print_AtomicInteger printABC = new Print_AtomicInteger();
        ExecutorService service = Executors.newFixedThreadPool(3);
        service.execute(printABC.new ThreadA());
        service.execute(printABC.new ThreadB());
        service.execute(printABC.new ThreadC());

        service.shutdown();
    }
}
```

# Java中的内部类

## 静态内部类

定义在类内部的静态类，就是静态内部类。静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式：**new 外部类.静态内部类()**。

## 成员内部类

定义在类内部，成员位置上的非静态类，就是成员内部类。成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式：**外部类实例.new 内部类()**。

## 局部内部类

定义在方法中的内部类，就是局部内部类。定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式：**在对应方法内，new 内部类()**。

## 匿名内部类

匿名内部类就是没有名字的内部类。除了没有名字，匿名内部类还有以下特点：

- 匿名内部类必须继承一个抽象类或者实现一个接口。
- 匿名内部类不能定义任何静态成员和静态方法。
- 当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。
- 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。

内部类的优点：

我们为什么要使用内部类呢？因为它有以下优点：

- 一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！
- 内部类不为同一包的其他类所见，具有很好的封装性；
- 内部类有效实现了“多重继承”，优化 java 单继承的缺陷。
- 匿名内部类可以很方便的定义回调。

内部类有哪些应用场景：

1. 一些多算法场合
2. 解决一些非面向对象的语句块。
3. 适当使用内部类，使得代码更加灵活和富有扩展性。
4. 当某个类除了它的外部类，不再被其他的类使用时。

# AVL树、红黑树、B树、B+树

## AVL树

简介：

AVL树是带有平衡条件的二叉查找树,一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡,左右子树树高不超过1,和红黑树相比,它是严格的平衡二叉树,平衡条件必须满足(所有节点的左右子树高度差不超过1).不管我们是执行插入还是删除操作,只要不满足上面的条件,就要通过旋转来保持平衡,而旋转是非常耗时的,由此我们可以知道AVL树适合用于插入删除次数比较少，但查找多的情况。

局限性：

由于维护这种高度平衡所付出的代价比从中获得的效率收益还大,故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树.当然,如果应用场景中对插入删除不频繁,只是对查找要求较高,那么AVL还是较优于红黑树。

应用：

windows NT内核中广泛存在。

## 红黑树

简介：

一种二叉查找树,但在每个节点增加一个存储位表示节点的颜色,可以是red或black. 通过对任何一条从根到叶子的路径上各个节点着色的方式的限制,红黑树确保没有一条路径会比其它路径长出两倍.它是一种弱平衡二叉树(**由于是弱平衡,可以推出,相同的节点情况下,AVL树的高度低于红黑树**),相对于要求严格的AVL树来说,它的旋转次数变少,所以对于**搜索,插入,删除操作多**的情况下,我们就用红黑树.

**性质：**

1. 每个节点不是红色就是黑色。
2. 根节点是黑色的。
3. 每个叶节点（树尾的NULL指针或者NULL节点）都是黑色的。
4. 如果一个节点是红色的，那么他的两个儿子节点都是黑色的。
5. 对于任意节点而言,其到叶子点树NIL指针的每条路径都包含相同数目的黑节点. 

应用：

1. 广泛用于C++的STL中,map和set都是用红黑树实现的.
2. 著名的linux进程调度[Completely Fair Scheduler](https://en.wikipedia.org/wiki/Completely_Fair_Scheduler),用红黑树管理进程控制块,进程的虚拟内存区域都存储在一颗红黑树上,每个虚拟地址区域都对应红黑树的一个节点,左指针指向相邻的地址虚拟存储区域,右指针指向相邻的高地址虚拟地址空间.
3. IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查.
4. ngnix中,用红黑树管理timer,因为红黑树是有序的,可以很快的得到距离当前最小的定时器.
5. **java中TreeMap的实现，HashMap的数据结构**。

## B树、B+树

简介：

B/B+树是为了磁盘或其它存储设备而设计的一种平衡多路查找树(相对于二叉,B树每个内节点有多个分支),与红黑树相比,在相同的的节点的情况下,一颗B/B+树的高度远远小于红黑树的高度(**在下面B/B+树的性能分析中会提到**).B/B+树上操作的时间通常由存取磁盘的时间和CPU计算时间这两部分构成,而CPU的速度非常快,所以B树的操作效率取决于访问磁盘的次数,关键字总数相同的情况下B树的高度越小，磁盘I/O所花的时间越少.

应用：

文件系统的索引、数据库的索引。

